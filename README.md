# inv_kinematics
# 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


This repository explains and shows the development of the thrid Lab, which main objective is to learn about inverse kinematics and trajectories.

Firstly, it is needed to remember the phantom X model, in which the inverse kinematics are developed.

The set of tools used in this aplication are the following libraries, specially spatialmath.base and RTB are the main tools to develop the Phantom model, the inverse kinematics, aditionally, position and rotation descriptions.
## Procedure

```python
from ctypes import sizeof
from json import tool
from unicodedata import name
import roboticstoolbox as rtb
from spatialmath import SE3
import numpy as np
from spatialmath.base import *
```
The model generated by RTB is shown below, this model  is constructed based on DHstd parameters gotten on the previous Lab (https://github.com/Wassau/Control-Px_robot.git). In this case it is important to set a tool, in order to check the orientation of the places that are chosen to track.
```python

Pincher = rtb.DHRobot(
    [
        rtb.RevoluteDH(alpha= np.pi/2, d= 14.45),
        rtb.RevoluteDH(a=10.49,offset=np.pi/2),
        rtb.RevoluteDH(a=10.7),
        rtb.RevoluteDH(alpha=np.pi/2)

    ], name="Pincher",
        # tool =SE3(transl(0 , 0 , 8))
)
```
After measuring the position of the targets, the inverse kinematics are calculated due to this poses, those are developed with the SE3 objects in the form of position * orientation. Afterwards, rtb.jtraj is used to make the joint trajectory; this method receives 3 parameters: initial joint configuration, final joint configuration and the number of steps between those configurations. By this way, the intermediate steps are calculated, in order to improve the movement between poses.

This process is iterative, this base code is implemented in the other positions to pick and place the objects type 1 and type 2. 
```python
T0 = SE3( 4, -4, 11 ) * SE3.OA([0, 1, 0], [0, 0, -1]) 
sol0 = Pincher.ikine_LM(T0)  
print('Pose1')
print(np.rad2deg(sol0.q))
qf = Pincher.fkine(np.round(sol0.q))
qt = rtb.jtraj([0, -np.pi/3, -np.pi/3, 0], sol0.q, 10)
qtdeg = np.rad2deg(np.round(qt.q))
print(qtdeg[1])
input()
for i in range(len(qt)):
    # q = Pincher.ikine_LM(qt[i],q0= config )
    # config = np.rad2deg(np.round(q.q))
    t2=qt.q[i]
    print(np.rad2deg(np.round(qt.q[i])))
    Pincher.plot(qt.q[i])
```
In this way the trajectories and positions have been plotted and obtained, so, the next step is just going into the drivers, in this step the code is recycled from px_robot repository using the roslauncher of px_controllers, also the Jointcommand methods are useful.

The next method transforms the joint configurations gotten previously  into driver's commands from 0 to 1023 bits of position; additionaly, it is important to taking into account the boundaries of the motors.
## Geometric approach to inverse kinematics
## First Joint
Starting with the inverse kinematics analysis, for the first joint we can observe in the diagyram of the robot that:

[![diagram-20220601.png](https://i.postimg.cc/4NbvD7Bv/diagram-20220601.png)](https://postimg.cc/9r0qTM3z)

$$\theta_1 = atan2 (y_T, x_T)$$
where $x_t$ and $y_t$ are the tool coordinates.

## kinematic decoupling
For the analysis it is necessary to reduce the number of variables to facilitate the procedure, that is why we resort to the technique of kinematic decoupling. To perform this procedure, we decouple the wrist of the last joint with a displacement of the value of $L4$ which refers to the size of the fourth link.    

The position of W is described by the following expression:

$$w=\begin{bmatrix}
x_T\\
y_T\\
z_T
\end{bmatrix} - L_4 \begin{bmatrix}
a_T\\
a_T\\
a_T
\end{bmatrix}$$

Where $a_x$ $a_y$ and $a_z$ are components of the approach vector that can be obtained from the rotation matrix of the tool.
## 2R mechanism, Second and Third Joint
To determine the second and third joint we can use a 2r mechanism, where we took from the second joint to the tool, obtaining a simpler problem to solve using the Pythagorean theorem, trigonometry and the cosine law.

As we can see in the following figure, we can appreciate the triangles formed between joints in the robot, obtaining the value of $//theta_2$ and $/theta_3$ corresponding to joints 2 and 3.


[![diagram-20220601-3.png](https://i.postimg.cc/rpJp14Cm/diagram-20220601-3.png)](https://postimg.cc/Z9WZZCQt)

$$\theta_2= atan2\frac{h}{r} - atan2 (\frac{L_3 \sin(\theta_3)}{L_2 + L_3 \cos(\theta_3)})$$

$$ acos(\frac{r²+h²-L_2²-L_3²}{2\cdot L_2 \cdot L_3})$$

We can see that it is a method that simplifies the inverse kinematic process and responds very well to the processes applied.

## Analysis

How many possible solutions are there for the inverse kinematics of the Phantom X manipulator?

We can observe when performing the inverse kinematics of the robot that we have to obtain two solutions for the given requirements, these solutions are known as the elbow up solution and the elbow down solution.

Dexterous workspace: Consists of the set of points that the manipulator can reach with an arbitrary orientation of its end-effector. manipulator can reach with an arbitrary orientation of its end-effector.



